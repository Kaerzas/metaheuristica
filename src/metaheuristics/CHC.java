package metaheuristics;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

import metaheuristics.evolutive.ICrossover;
import metaheuristics.evolutive.ISelection;

import org.apache.commons.configuration.Configuration;

import problems.ISolution;
import util.config.IConfiguration;

public class CHC extends AbstractAlgorithm{
		
	private List<ISolution> population;
	private double threshold; // Incest's limit
	
	// Configurable params
	private int nPopulation;
	private double percentThreshold;
	private ISelection selection;
	private ICrossover crossover;
	
	
	@Override
	protected void search(){
		threshold = instance.getLength()*percentThreshold;
		
		initialize();
		//TODO evaluate
		
		while(stopwatch.currentElapsed() < maxTime){
			List<ISolution> newPopulation = new ArrayList<ISolution>(population);
			List<ISolution> children = new ArrayList<ISolution>(nPopulation/2);
			
			if(!crossover(children))
				threshold--;
			else{
				newPopulation.addAll(children);
				selection.select(newPopulation, nPopulation);
			}
			if(threshold > 0)
				restart(newPopulation);
			
			population=newPopulation;
		}
	}
	
	/**
	 * Given a solution generator, initialize a empty population
	 */
	private void initialize(){
		population = new ArrayList<ISolution>(nPopulation);
		for(int i=0; i<nPopulation; ++i){
			ISolution newSolution = generator.generate();
			population.add(newSolution);
		}
	}
		
	/**
	 * Crossover population in random pairs with a given ICrossover
	 * @param children save the nPopulation/2 children generated by pairs of ISolutions
	 * @return true if there has been cross, false otherwise 
	 */
	private boolean crossover(List<ISolution> children){
		List<Integer> indices = new ArrayList<Integer>(nPopulation);
		for(int i=0; i<nPopulation; ++i)
			indices.add(i);
		Collections.shuffle(indices); //Random pairs achieved with indices permutations
		
		boolean thereIs=false;
		for(int i=0; i<nPopulation-1; i+=2){
			if(instance.hamming(population.get(i), population.get(i+1)) > threshold){
				ISolution child = crossover.cross(population.get(i), population.get(i+1));
				children.add(child);
				thereIs=true;
			}
		}
		return thereIs;
	}
	
	/**
	 * Restart a population keeping the best ISolution
	 * @param newPopulation uniform population to be restarted
	 */
	public void restart(List<ISolution> newPopulation){
		int best=0;
		for(int i=1; i<newPopulation.size(); ++i)
			if(instance.betterThan(newPopulation.get(i), newPopulation.get(best)))
				best=i;
		ISolution kept = newPopulation.get(best);
		
		newPopulation.clear();
		newPopulation.add(kept);
		for(int i=0; i<newPopulation.size()-1; ++i)
			newPopulation.add(generator.generate()); //TODO how to assure rand generator????????
	}
	
	
	@SuppressWarnings("unchecked")
	@Override
	public void configure(Configuration configuration){
		//Standard configuration
		super.configure(configuration);
		
		this.nPopulation = configuration.getInt("nPopulation");
		this.percentThreshold = configuration.getDouble("percentThreshold");
		if(percentThreshold < 0.0 || percentThreshold > 1.0){
			System.err.println("Percent's Threshold must be between 0 and 1");
			System.exit(1);
		}
		
		try{
			// Get the name of the explorer class
			String instanceName = configuration.getString("selection[@name]");
			// Instance class
			Class<? extends ISelection> instanceClass = 
					(Class<? extends ISelection>) Class.forName(instanceName);
			
			selection = instanceClass.newInstance();
			//selection.setInstance(instance);
			if(selection instanceof IConfiguration)
				((IConfiguration) selection).configure(configuration.subset("selection"));
		}
		catch(Exception e) {
			System.out.println(e);
			System.exit(1);
		}
	}
}
