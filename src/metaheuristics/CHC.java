package metaheuristics;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

import org.apache.commons.configuration.Configuration;

import metaheuristics.evolutive.ICrossover;
import metaheuristics.evolutive.ISelection;
import problems.ISolution;
import util.config.IConfiguration;

public class CHC extends AbstractAlgorithm{
		
	private List<ISolution> population;
	private int threshold; // Incest's limit
	
	// Configurable params
	private int nPopulation;
	private double percentThreshold;
	private ISelection selection;
	private ICrossover crossover;
	
	
	@Override
	protected void search(){
		int initialThreshold = (int) (instance.getLength() * percentThreshold);
		threshold = initialThreshold;
		
		initialize();
		
		while(!maxTimeReached()){
			//Log best solution in generation
			int best = 0;
			for(int i=1 ; i < nPopulation ; ++i){
				if(instance.betterThan(population.get(i), population.get(best)))
					best = i;
			}
			logSolution(population.get(best));
			
			List<ISolution> newPopulation = new ArrayList<ISolution>(population);
			List<ISolution> children = new ArrayList<ISolution>(nPopulation/2);
			
			if(!crossover(children))
				threshold--;
			else{
				newPopulation.addAll(children);
				newPopulation = selection.select(newPopulation, nPopulation);
			}
			if(threshold < 0){
				System.err.println("Population restarted");
				restart(newPopulation);
				threshold = initialThreshold;
			}
			
			population=newPopulation;
		}
	}
	
	/**
	 * Given a solution generator, initialize a empty population
	 */
	private void initialize(){
		population = new ArrayList<ISolution>(nPopulation);
		for(int i=0; i<nPopulation; ++i){
			ISolution newSolution = generator.generate();
			population.add(newSolution);
		}
	}
		
	/**
	 * Crossover population in random pairs with a given ICrossover
	 * @param children save the nPopulation/2 children generated by pairs of ISolutions
	 * @return true if there has been cross, false otherwise 
	 */
	private boolean crossover(List<ISolution> children){
		List<Integer> indices = new ArrayList<Integer>(nPopulation);
		for(int i=0; i<nPopulation; ++i)
			indices.add(i);
		Collections.shuffle(indices); //Random pairs achieved with indices permutations
		
		boolean thereIs=false;
		for(int i=0; i<nPopulation-1; i+=2){
			int parentA = indices.get(i);
			int parentB = indices.get(i+1);
			if(instance.hamming(population.get(parentA), population.get(parentB)) > threshold){
				ISolution child = crossover.cross(population.get(parentA), population.get(parentB));
				children.add(child);
				thereIs=true;
			}
		}
		return thereIs;
	}
	
	/**
	 * Restart a population keeping the best ISolution
	 * @param newPopulation uniform population to be restarted
	 */
	public void restart(List<ISolution> newPopulation){
		int best=0;
		for(int i=1; i<newPopulation.size(); ++i)
			if(instance.betterThan(newPopulation.get(i), newPopulation.get(best)))
				best=i;
		ISolution kept = newPopulation.get(best);
		
		newPopulation.clear();
		newPopulation.add(kept);
		for(int i=0; i< nPopulation-1; ++i)
			newPopulation.add(generator.generate()); //TODO how to assure rand generator????????
	}
	
	
	@SuppressWarnings("unchecked")
	@Override
	public void configure(Configuration configuration){
		//Standard configuration
		super.configure(configuration);
		
		this.nPopulation = configuration.getInt("nPopulation");
		this.percentThreshold = configuration.getDouble("percentThreshold");
		if(percentThreshold < 0.0 || percentThreshold > 1.0){
			System.err.println("Percent's Threshold must be between 0 and 1");
			System.exit(1);
		}
		
		try{
			// Get the name of the selection class
			String selectionName = configuration.getString("selection[@name]");
			// Instance class
			Class<? extends ISelection> selectionClass = 
					(Class<? extends ISelection>) Class.forName(selectionName);
			
			selection = selectionClass.newInstance();
			selection.setInstance(instance);
			if(selection instanceof IConfiguration)
				((IConfiguration) selection).configure(configuration.subset("selection"));
			
			// Get the name of the crossover class
			String crossName = configuration.getString("crossover[@name]");
			// Instance class
			Class<? extends ICrossover> crossClass = 
					(Class<? extends ICrossover>) Class.forName(crossName);
			
			crossover = crossClass.newInstance();
			crossover.initialize(instance);
			if(crossover instanceof IConfiguration)
				((IConfiguration) crossover).configure(configuration.subset("crossover"));
		}
		catch(Exception e) {
			System.out.println(e);
			System.exit(1);
		}
	}
}
